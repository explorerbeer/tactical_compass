-- Developments were utilized: GhenTuong --
-- Edited by: explorerbee --
-- Date: 21.09.2024 --

--[[--------------------------------------------------
	Constants
--------------------------------------------------]]--

MIN_DISTANCE = 1
MAX_DISTANCE_TO_NPC = 50
MAX_DISTANCE_TO_QUEST = 300

MAX_DISTANCE_TO_OTHERS = 50
MAX_DISTANCE_TO_CAMPFIRES = 30
MAX_DISTANCE_TO_SLEEP = 50
MAX_DISTANCE_TO_STASH = 100
MAX_DISTANCE_TO_TRANSITION = 200

COMPASS_CENTER = 505

--[[--------------------------------------------------
	Variables
--------------------------------------------------]]--

local compass_marker_task = nil

local marker_task_id = nil
local marker_task_current_target_id = nil

local sleep_zone_id = nil

local is_storyline = nil

local distance_state = true 
local compass_state = true

class "UICompassMarker" (CUIScriptWnd)

--[[--------------------------------------------------
	Store tables
--------------------------------------------------]]--

local unique_npcs = {}
local other_markers = {}
local active_campfires = {}

--[[--------------------------------------------------
	Generic tables
--------------------------------------------------]]--

local unique_npcs_spots = {
    ui_pda2_special_location = true,
    ui_pda2_trader_location = true,
    ui_pda2_mechanic_location = true,
    ui_pda2_scout_location = true,
    ui_pda2_barman_location = true,
    ui_pda2_quest_npc_location = true,
    ui_pda2_medic_location = true,
    ui_pda2_companion_location = true
}

local sleep_zones = {
    "mar_a3_sr_sleep_id",
    "agr_sr_sleep_wagon_id",
    "agr_sr_sleep_tunnel_id",
    "agr_army_sleep_id",
    "esc_basement_sleep_area_id",
    "esc_secret_sleep_id",
    "ds_farmhouse_sleep_id",
    "val_abandoned_house_sleep_id",
    "val_vagon_sleep_id",
    "gar_dolg_sleep_id",
    "gar_angar_sleep_id",
    "bar_actor_sleep_zone_id",
    "yan_bunker_sleep_restrictor_id",
    "ros_vagon_sleep_id",
    "mil_freedom_sleep_id",
    "mil_smart_terran_2_4_sleep_id",
    "rad_sleep_room_id",
    "cit_merc_sleep_id",
    "pri_monolith_sleep_id",
    "pri_room27_sleep_id",
    "zat_a2_sr_sleep_id",
    "jup_a6_sr_sleep_id",
    "pri_a16_sr_sleep_id",
    "pol_secret_sleep_id"
}

local treasure_types = {
    "treasure_all",
    "treasure_unique",
    "treasure_searched",
    "treasure_player",
    "treasure"
}

local transitions = {
    "up",
    "up_right",
    "right",
    "right_down",
    "down",
    "down_left",
    "left",
    "left_up"
}

--[[--------------------------------------------------
	(Marker) Handlers
--------------------------------------------------]]--

function activate_markers()
	if compass_marker_task == nil then
		compass_marker_task = UICompassMarker()
		get_hud():AddDialogToRender(compass_marker_task)
	end

end

function deactivate_markers()
	if compass_marker_task ~= nil then
		get_hud():RemoveDialogToRender(compass_marker_task)
		compass_marker_task = nil
	end
end

function update_markers()
    if compass_marker_task ~= nil then
		compass_marker_task:RefreshMarkers()
    end
end

--[[--------------------------------------------------
    (Marker) Class init & draw
--------------------------------------------------]]--

function UICompassMarker:__init()
    super()
    self._tmr = time_global()
    self:InitControls()
end

function UICompassMarker:__finalize()
end

function UICompassMarker:InitControls()
    distance_state = compass_mcm.get_config("d_t_show")

    self:SetAutoDelete(true)


    self.xml = CScriptXmlInit()
    self.xml:ParseFile("tactic_marker.xml")

    self.markers_list = self.xml:InitStatic("markers", self)

    --Quests
    self.marker_primary = self.xml:InitStatic("markers:marker_primary", self.markers_list)
    self.marker_text_pr = distance_state and self.xml:InitTextWnd("markers:marker_primary:text_item_m_pr", self.marker_primary) or nil

    self.marker_secondary = self.xml:InitStatic("markers:marker_secondary", self.markers_list)
    self.marker_text_sec = distance_state and self.xml:InitTextWnd("markers:marker_secondary:text_item_m_sec", self.marker_secondary) or nil

    --Unique NPCs
    self.unique_npcs = {}

    --Other Markers
    self.others = {}

    --Campfires
    self.campfires = {}
end

function UICompassMarker:RefreshMarkers()
    local compass_pos_state = compass_mcm.get_config("compass_sc_pos")

    if not main_hud_shown() then
        return
    end

    local actor = db.actor
    local actor_pos = actor:position()
    local actor_dir = actor:direction()

    -- Обновление квестовых маркеров
    local target_screen_pos = marker_task_current_target_id and self:GetScreenCoordinates(marker_task_current_target_id)
    local target_world_pos = marker_task_current_target_id and self:GetWorldCoordinates(marker_task_current_target_id)
    local distance_to_target = self:CalculateDistanceToTarget(target_world_pos, actor_pos)

    -- Если не удалось рассчитать расстояние до цели, скрываем маркеры и выходим
    if not distance_to_target then
        self.marker_primary:Show(false)
        self.marker_secondary:Show(false)
    end

    -- Если нет координат метки на экране, скрываем маркеры и выходим
    if not target_screen_pos then
        self.marker_primary:Show(false)
        self.marker_secondary:Show(false)
    else
        if is_storyline == "true" then
            self.marker_secondary:Show(false)
        else
            self.marker_primary:Show(false)
        end
    end

    local marker = (is_storyline == "true") and self.marker_primary or self.marker_secondary
    local marker_text = (is_storyline == "true") and self.marker_text_pr or self.marker_text_sec

    local marker_x = target_world_pos and self:CalculatePosition(target_world_pos, actor_pos, actor_dir, MAX_DISTANCE_TO_QUEST, self.prev_marker_x)
    local marker_y = (compass_pos_state == 1) and 701 or 10

    local marker_alpha = distance_to_target and self:CalculateAlpha(distance_to_target, MIN_DISTANCE, MAX_DISTANCE_TO_QUEST) or 0

    if marker_x and marker_x > 290 and marker_x < 740 then
        marker:Show(true)
        marker:SetWndPos(vector2():set(marker_x, marker_y))
        marker:SetTextureColor(GetARGB(marker_alpha, 255, 255, 255))

        if marker_text then
            marker_text:Show(true)
            marker_text:SetText(math.floor(distance_to_target))
            marker_text:SetTextColor(GetARGB(marker_alpha, 255, 255, 255))
        end
    else
        marker:Show(false)
        if marker_text then marker_text:Show(false) end
    end

    self.prev_marker_x = marker_x

    self.prev_npc_spots = self.prev_npc_spots or {}

    for npc_id, spot_data in pairs(unique_npcs) do
        local spot_type = spot_data.spot:match("ui_pda2_(.+)_location")
        if spot_type then
            local marker_npc
            -- Проверяем, изменился ли тип маркера для NPC
            if self.prev_npc_spots[npc_id] ~= spot_type then
                if self.unique_npcs[npc_id] then
                    self.unique_npcs[npc_id] = nil
                end

                -- Если изменился, создаем новый маркер
                marker_npc = self.xml:InitStatic("markers:marker_" .. spot_type, self.markers_list)
                self.unique_npcs[npc_id] = marker_npc

                -- Обновляем тип маркера для данного NPC
                self.prev_npc_spots[npc_id] = spot_type
            else
                -- Если не изменился, используем существующий маркер
                marker_npc = self.unique_npcs[npc_id]
            end

            local npc_world_pos = npc_id and self:GetWorldCoordinates(npc_id)

            if npc_world_pos then                
                distance_to_target = self:CalculateDistanceToTarget(npc_world_pos, actor_pos)
                marker_x = self:CalculatePosition(npc_world_pos, actor_pos, actor_dir, MAX_DISTANCE_TO_NPC, self.prev_npc_positions and self.prev_npc_positions[npc_id])

                marker_alpha = distance_to_target and self:CalculateAlpha(distance_to_target, MIN_DISTANCE, MAX_DISTANCE_TO_NPC)

                if marker_x and marker_x > 290 and marker_x < 740 then
                    marker_npc:Show(true)
                    marker_npc:SetWndPos(vector2():set(marker_x, marker_y))
                    marker_npc:SetTextureColor(GetARGB(marker_alpha, 255, 255, 255))
                else
                    marker_npc:Show(false)
                end

                self.prev_npc_positions = self.prev_npc_positions or {}
                self.prev_npc_positions[npc_id] = marker_x
            else
                marker_npc:Show(false)
            end
        end
    end

    for id, other_marker in pairs(self.others) do
        if not other_markers[id] then
            self.others[id] = nil -- Удаляем маркер из self.others, если он больше не нужен
        end
    end

    for id, type in pairs(other_markers) do
        local marker_type = other_markers[id] and other_markers[id].type
        local distance_threshold = self:DefineMarkerType(marker_type)

        local other_marker

        other_marker = self.others[id] or self.xml:InitStatic("markers:marker_" .. marker_type, self.markers_list)
        self.others[id] = other_marker

        local obj_world_pos = id and self:GetWorldCoordinates(id)

        if obj_world_pos then

            distance_to_target = self:CalculateDistanceToTarget(obj_world_pos, actor_pos)
            marker_x = self:CalculatePosition(obj_world_pos, actor_pos, actor_dir, distance_threshold, self.prev_obj_positions and self.prev_obj_positions[id])

            marker_alpha = distance_to_target and self:CalculateAlpha(distance_to_target, MIN_DISTANCE, distance_threshold)

            if marker_x and marker_x > 290 and marker_x < 740 then
                other_marker:Show(true)
                other_marker:SetWndPos(vector2():set(marker_x, marker_y))
                other_marker:SetTextureColor(GetARGB(marker_alpha, 255, 255, 255))
            else
                other_marker:Show(false)
            end

            self.prev_obj_positions = self.prev_obj_positions or {}
            self.prev_obj_positions[id] = marker_x
        else
            other_marker:Show(false)
        end        
    end

    self.prev_campfire = self.prev_campfire or {}

    for id, camp_type in pairs(active_campfires) do
        local marker_type = active_campfires[id] and camp_type.type
        printf("id: %s, marker_type: %s", id, marker_type)

        local camp_marker

        if self.prev_campfire[id] ~= marker_type then
            if self.campfires[id] then
                self.campfires[id] = nil
            end

            camp_marker = self.xml:InitStatic("markers:marker_" .. marker_type, self.markers_list)
            self.campfires[id] = camp_marker

            self.prev_campfire[id] = marker_type
        else
            camp_marker = self.campfires[id]
        end

        local camp_world_pos = id and self:GetWorldCoordinates(id)

        if camp_world_pos then
            distance_to_target = self:CalculateDistanceToTarget(camp_world_pos, actor_pos)
            marker_x = self:CalculatePosition(camp_world_pos, actor_pos, actor_dir, MAX_DISTANCE_TO_CAMPFIRES, self.prev_campfire_pos and self.prev_campfire_pos[id])
 
            marker_alpha = distance_to_target and self:CalculateAlpha(distance_to_target, MIN_DISTANCE, MAX_DISTANCE_TO_CAMPFIRES)

            if marker_x and marker_x > 290 and marker_x < 740 then
                camp_marker:Show(true)
                camp_marker:SetWndPos(vector2():set(marker_x, marker_y))
                camp_marker:SetTextureColor(GetARGB(marker_alpha, 255, 255, 255))
            else
                camp_marker:Show(false)
            end

            self.prev_campfire_pos = self.prev_campfire_pos or {}
            self.prev_campfire_pos[id] = marker_x
        else
            camp_marker:Show(false)
        end
    end
end

function UICompassMarker:CalculatePosition(world_pos, actor_pos, actor_dir, max_distance, prev_marker_x)
    local marker_pos = COMPASS_CENTER
    
    -- Рассчитываем расстояние до цели
    local distance_to_target = world_pos:distance_to(actor_pos)
    if distance_to_target > max_distance then
        return nil -- Если цель слишком далеко, не отображаем метку
    end

    local target_dir = world_pos:sub(actor_pos):normalize()
    local dot_product = target_dir:dotproduct(actor_dir)

    if dot_product < -0.99 then  -- Угол близок к 180 градусов
        return tonumber(clamp(COMPASS_CENTER - 215, COMPASS_CENTER + 235))
    end

    local cross = VEC_ZERO
    cross:crossproduct(target_dir, actor_dir)
    local side_factor = (cross.y < 0) and 1 or -1
    local offset = side_factor * (1 - dot_product) * 220

    marker_pos = COMPASS_CENTER + offset

    local lerp_factor = 0.1
    if prev_marker_x and math.abs(marker_pos - prev_marker_x) > 100 then
        lerp_factor = 0.5  -- Увеличиваем скорость при большом расхождении
    end

    marker_pos = utils_compass.lerp(prev_marker_x or COMPASS_CENTER, marker_pos, lerp_factor)
    marker_pos = clamp(marker_pos, COMPASS_CENTER - 215, COMPASS_CENTER + 235)

    return tonumber(marker_pos)
end

function UICompassMarker:DefineMarkerType(marker_type)
    if marker_type == "stashes" then
        return MAX_DISTANCE_TO_STASH
    elseif marker_type == "sleep" then
        return MAX_DISTANCE_TO_SLEEP
    elseif marker_type == "transition" then
        return MAX_DISTANCE_TO_TRANSITION
    else
        return MAX_DISTANCE_TO_OTHERS
    end
end

function UICompassMarker:Update()
    CUIScriptWnd.Update(self)
    self:RefreshMarkers()
end

--[[--------------------------------------------------
	Marker (utils)
--------------------------------------------------]]--

function marker_task_actor_on_update()
    local tm = task_manager
	local task_info = tm.get_task_manager().task_info

	if (task_info) then
		if (marker_task_id) then
			local task = task_info[marker_task_id]
            
			if (task and db.actor:is_active_task(task.t)) then
				if (marker_task_id ~= tostring(task_id)) then
					marker_task_id = tostring(task_id)
				end
				
				if (marker_task_current_target_id ~= tonumber(task.current_target)) then
					marker_task_current_target_id = tonumber(task.current_target)
				end
				return
			else
				marker_task_id = nil
				marker_task_current_target_id = nil
			end
		end
		
		if (marker_task_id == nil) then
			for task_id, task in pairs(task_info) do
				if (task and task.t and db.actor:is_active_task(task.t)) then
                    
					if (marker_task_id ~= tostring(task_id)) then
						marker_task_id = tostring(task_id)

                        is_storyline = tm.task_ini:r_string_ex(marker_task_id, "storyline")
					end
					
					if (marker_task_current_target_id ~= tonumber(task.current_target)) then
						marker_task_current_target_id = tonumber(task.current_target)
					end

					return
				end
			end
		end
	end
end

--Get stashes, sleep zones, (in future campfires, water_pumps, corpses) etc.
function get_unique_npcs()
    for i = 1, #db.OnlineStalkers do
        local id = db.OnlineStalkers[i]
        local npc = id and id ~= 0 and level.object_by_id(id)
        
        if npc and IsStalker(npc) then
            for k, v in pairs(unique_npcs_spots) do
                if level.map_has_object_spot(id, k) ~= 0 then
                    -- Если npc уже существует, обновляем его информацию
                    if not unique_npcs[id] then
                        unique_npcs[id] = {spot = k}
                    else
                        -- Если npc существует, обновляем только spot, если он изменился
                        if unique_npcs[id].spot ~= k then     
                            unique_npcs[id].spot = k
                        end
                    end
                    break -- Выходим из внутреннего цикла, если нашли подходящий spot
                end
            end
        end
    end
end

--Get stashes, sleep zones, (in future campfires, water_pumps, corpses) etc.
function get_other_markers()
    for i = 1, #sleep_zones do
        local sz_id = get_story_object_id(sleep_zones[i])

        if sz_id and level.map_has_object_spot(sz_id, "ui_pda2_actor_sleep_location") ~= 0 then
            if not other_markers[sz_id] then
                other_markers[sz_id] = {type = "sleep"} -- Добавляем новый элемент, если его нет
            end
        end
    end

    for id, v in pairs(treasure_manager.caches) do
        for _, spot in ipairs(treasure_types) do
            if level.map_has_object_spot(id, spot) ~= 0 then
                if not other_markers[id] then
                    other_markers[id] = { type = "stashes" }
                end
                break -- Прерываем цикл, если хотя бы одно условие выполнено
            else
                other_markers[id] = nil
            end
        end
    end

    local m_data = alife_storage_manager.get_state()

    if m_data.player_created_stashes then
        for id, _ in pairs(m_data.player_created_stashes) do
            if level.map_has_object_spot(id, "treasure") then
                if not other_markers[id] then
                    other_markers[id] = { type = "stashes" }
                end
            end
        end
    end

    for id, v in pairs(db.storage) do
        local obj = level.object_by_id(id)

        if obj then
            for j = 1, #transitions do
                local tracker = "level_changer_" .. transitions[j]

                if level.map_has_object_spot(id, tracker) ~= 0 then
                    if not other_markers[id] then
                        other_markers[id] = { type = "transition" }
                    end
                end
            end
        end
    end

    --Display Campfires on Minimap required
    for id, binder in pairs(bind_campfire.campfires_all) do 
        if binder and binder.campfire then
            local is_lit = binder.campfire:is_on()
            local lit_status = is_lit and "campfire_lit" or "campfire_unlit"
    
            if level.map_has_object_spot(id, lit_status) then
                -- Если объект имеет spot на карте и костер не добавлен в таблицу campfires
                if not active_campfires[id] then
                    -- Добавляем метку костра
                    active_campfires[id] = { type = lit_status }
                else
                    -- Если статус костра изменился, обновляем тип
                    if active_campfires[id].type ~= lit_status then
                        active_campfires[id].type = lit_status
                    end
                end
            end
        end 
    end
end

function UICompassMarker:GetWorldCoordinates(id)
	local pos = nil
	local obj = db.storage[id] and db.storage[id].object or level.object_by_id(id)
	
	if (obj and (IsStalker(obj) or IsMonster(obj))) then
		pos = obj and utils_obj.safe_bone_pos(obj, "bip01_head")

        return pos
	elseif (obj and (type(obj.position) == "function")) then
		local tmp = obj:position()
		pos = tmp and vector():set(tmp.x, tmp.y + 1, tmp.z)

        return pos
	end
	
	if (pos == nil) then
		local se = alife_object(id)
		if not (se and se.online) then
			return nil
			
		elseif (se:clsid() == clsid.smart_terrain) then
			local tmp = se and se.position
			pos = tmp and vector():set(tmp.x, tmp.y + 1, tmp.z)
			
            return pos
		elseif (se:clsid() == clsid.online_offline_group_s) then
			local i = se:commander_id()
			local npc = i and db.storage[i] and db.storage[i].object or level.object_by_id(i)
			pos = npc and utils_obj.safe_bone_pos(npc, "bip01_head")

            return pos
		end
	end

	return nil
end

function UICompassMarker:GetScreenCoordinates(id)
    local pos = id and self:GetWorldCoordinates(id)

    local vec = pos and game.world2ui(vector():set(pos.x, pos.y + 0.5, pos.z), false)
	
    return vec
end

function UICompassMarker:CalculateDistanceToTarget(target_world_pos, actor_pos)
    if target_world_pos and actor_pos then
        return math.floor(target_world_pos:distance_to(actor_pos))
    end
    return nil  -- Возвращаем nil, если позиции не определены
end

function UICompassMarker:CalculateAlpha(distance_to_npc, min_distance, max_distance)
    return 1 - clamp((distance_to_npc - min_distance) / (max_distance - min_distance) * 255, 0, 255) 
end

--[[--------------------------------------------------
    Callbacks
--------------------------------------------------]]--

function on_option_change()
    compass_state = compass_mcm.get_config("t_c_show")
    local ui_state = ui_options.get('video/hud/show_hud')

    if compass_state then
        if (not compass_marker_task) then
            activate_markers()
        end
    else
        if compass_marker_task then
            deactivate_markers()
        end
    end

    if (not ui_state) and compass_marker_task then
        deactivate_markers()
    end
end

function on_console_execute(name)
    if name == "hud_draw" and compass_marker_task then
        compass_marker_task:Refresh()
    end
end

function actor_on_net_destroy()
    deactivate_markers()
end

function update_marker_hud()
    update_markers()
end

function actor_on_first_update()
    activate_markers()
end

--[[--------------------------------------------------
    Register callbacks
--------------------------------------------------]]--

function on_game_start()
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("on_console_execute", on_console_execute)
    
    RegisterScriptCallback("GUI_on_show", update_marker_hud)
    RegisterScriptCallback("GUI_on_hide", update_marker_hud)

    RegisterScriptCallback("actor_on_update", marker_task_actor_on_update)

    RegisterScriptCallback("actor_on_update", get_unique_npcs)
    RegisterScriptCallback("actor_on_update", get_other_markers)
end